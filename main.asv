%%   main code for S3CD model

clear;clc;close all;

%% prepare data
im_path = './data/';
gt_path = './GT/';
im_suffix = '.jpg';
gt_suffix = '.png';
imgs_list = dir(strcat(im_path,'*',im_suffix));
sample_num = length(imgs_list);

% prepare deep feature
% feat_path = './deepfeature/';
% feat_suffix = '.mat'
% feat_list = dir(strcat(feat_path,'*',feat_suffix));


%% main
i=12;
fprintf('Processing %d image...\n',i);
im_name = imgs_list(i).name;
im_idx = im_name(1:strfind(im_name,'.')-1);
img.RGB = imread(strcat(im_path,im_name));
% img.RGB = cat(3, img.RGB, img.RGB,img.RGB);  


gt_name = strcat(im_idx,gt_suffix);
gt_im = imread(strcat(gt_path,gt_name));
[height,width,d] = size(gt_im);

%% get feature matrtix

%input deep feature
j=1;
fprintf('Processing %d image...\n',j);

% tic;
% [view, pixelList, sup, adjc_mat, seg_im] = GenChaFeatMat(img);
[view, pixelList, sup, adjc_mat, seg_im, fstReachMat, bgPrior, bdCon,W] = GenChaFeatMat(img);
[len,dim] = size(view); 
view1 = view(:,1)';
view2 = view(:,2:13)';
view3 = view(:,14:49)';
% view4 = view(:,50:113)';
% view5 = view(:,114:end)';
% toc;
X_feature = cat(1, view1, view2, view3);

%%  低秩矩阵分解计算


%load data
Data = {view1,view2,view3};  %,view2,view3 ,view4  ,view5

tic;
 [Z, E] = S3CD(Data);  
toc;


%% postprocessing

result1 = zeros(1,len);

for i = 1:length(Z)
        result1 = result1 + sum(abs(Z{i}), 1);
end


Res = mapminmax(result1,0,1);


intial_result = zeros(height,width);
for i=1:length(pixelList)
    intial_result(pixelList{i}) = Res(i);
end
figure;imshow(intial_result);


% close all;

%%     融合
lambda = 0.5;
Z_fuse = lambda * (mapminmax(Res,0,1)') + (1-lambda) * (mapminmax(bgPrior',0,1)');

zz = Z_fuse;

intial_result2 = zeros(height,width);
for i=1:length(pixelList)
    intial_result2(pixelList{i}) = zz(i);
end
figure;imshow(intial_result2);

%%  引入细化模块
% % 
%样本筛选；

cc=zz'; %cc=R_lr2;
% threshold strategy
mean_th = 1.5;   %参数
min_th=0.5;

pos_index = find(cc>mean_th*mean(cc));   %mean_th*
neg_index = find(cc<min_th*mean(cc));
known_index = [pos_index, neg_index];

unk_index = setdiff(1:length(cc), known_index); %不确定像素的索引
pixel_amount = sup.pixNum;   %每个超像素块包含的像素数目


%画一下三分类的结果
aa1 = cc;
for ind = 1:length(unk_index)
    aa1(unk_index(ind)) = 0.5; 
end
for ind = 1:length(pos_index)
    aa1(pos_index(ind)) = 1;  
end
for ind = 1:length(neg_index)
    aa1(neg_index(ind)) = 0;  
end
img_class = zeros(height, width);
for i=1:length(pixelList)
    img_class(pixelList{i}) = aa1(i);
end
figure;imshow(img_class); title('初步三分类的结果');  

% spatial adjacency
    % for ind = 1:length(unk_index)
    %     adj_index = adjc_mat(unk_index(ind),:);
    %     adj_index(unk_index(ind)) = 0;
    %     int_label(unk_index(ind)) = sum(cc.*adj_index.*pixel_amount)/sum(adj_index.*pixel_amount);
    % end

% sample selection
tic;
idx_n = cc<min_th*mean(cc);
im_sample_n = F(idx_n,:);   %负样本的特征矩阵
% idx_p = S_l1>mean_th*mean(S_l1);
idx_p = cc>mean_th*mean(cc);
im_sample_p = F(idx_p,:);   %正样本的特征矩阵
num_p = length(find(idx_p>0));
num_n = length(find(idx_n>0));    %统计正负样本的数目

im_sample_k = vertcat(im_sample_n,im_sample_p);
im_label_k = zeros(num_n+num_p,2);
im_label_k(1:num_n,2) = 1;
im_label_k(num_n+1:end,1) = 1;   %正负样本的标签  正【1,0】 负【0,1】

im_idx_k = union(find(idx_n>0), find(idx_p>0));   %正负样本超像素的索引  
im_idx_unk = setdiff(1:length(result3), im_idx_k);   %不确定样本的索引
im_sample_unk = F(im_idx_unk,:);            %不确定样本的特征矩阵
im_label_unk = zeros(length(im_idx_unk),2);       
im_label_unk(:,1) = cc(im_idx_unk);
im_label_unk(:,2) = 1-im_label_unk(:,1);          %不确定样本的标签

% 构建正负样本的邻接矩阵
selected_adj_mat = adjc_mat(im_idx_k, im_idx_k);

% weights = zeros(1,num_n+num_p);
 weights = zeros(1,length(pixelList));
weights(1:num_n) = 1;
weights(num_n+1:num_n+num_p) = num_n/num_p;
 weights(num_n+num_p+1:end) = 0.5;

    % saliency refinement 
    train_x = [im_sample_k; im_sample_unk];
    train_y = [im_label_k; im_label_unk];
    train_x = mapminmax(train_x,0,1);
    %  train_x = [im_sample_k];
    % train_y = [im_label_k];
    % train_x = mapminmax(train_x,0,1);
    % pre_x = [im_sample_unk];


% 参数设置
eta_1 = 0.0001;    
sigma_kernel = 1; 
eta_2 = 1000;       

tic;
% 调用函数
 % pred = fine_proc_krr_laplacian(train_x,pre_x, train_y, weights, eta_1, selected_adj_mat, sigma_kernel, eta_2);
pred = fine_proc_krr_laplacian2(train_x, train_y, weights, eta_1, adjc_mat, sigma_kernel, eta_2);
toc;
% prediction = pred(num_n+num_p+1:end,:);
% pred_lb = zeros(1, length(pixelList));
% pred_lb(im_idx_k) = cc(im_idx_k);
% pred_lb(im_idx_unk) = pred(:,1);

final_labels = -ones(length(pixelList), 1);
final_labels(neg_index) = 0; %1;
final_labels(pos_index) = 1; %0;
final_labels(unk_index) = 2-pred(num_n+num_p+1:end);


%结果
dd = final_labels*255;

first_slience1 = zeros(height,width);
for i=1:length(pixelList)
    first_slience1(pixelList{i}) = dd(i);
end
figure;imshow(first_slience1); title('细化的');

figure;
[X1,Y1] = meshgrid(1:x,y:-1:1);         % 生成网格坐标
pcolor(X1,Y1,  first_slience1);
 %surf(x,y,z); view(0,90); %等效的写法
shading interp; 
colorbar; colormap(summer);
% clim([0 1]);
xlabel('X');ylabel('Y');
title('细化的');  


%% 细化后的结果（加入先验）
out1 = reshape(first_slience1, height*width, []);
[centers, U] = fcm( out1, 2);
[values, indexes] = max(U);
fcmClusters = reshape(indexes, [height,width]);

gt8=fcmClusters-1;
% gt8 = 1-gt8;
figure;imshow(gt8);title('后处理，有先验的');


[TN,TP,FN,FP,OE,KC]=Kappa(gt_im(:,:,1), gt8);
AC=(TP+TN)/(TP+FN+FP+TN);    %准确率
PR=TP/(TP+FP);          %精确度
RCALL=TP/(TP+FN);      %召回率
F1=2*TP/(2*TP+FP+FN);   %f1值



%% 加先验
lambda = 0.8;
tic;
% Z_sal = lambda * (1-mapminmax(result3,0,1)') + (1-lambda) * (1 - mapminmax(bgPrior',0,1)');
% Z_sal = lambda * (1-mapminmax(cc,0,1)') + (1-lambda) * (1 - mapminmax(bgPrior',0,1)');
% Z_sal = lambda * (1-mapminmax(result4,0,1)') + (1-lambda) * (1 - mapminmax(bgPrior',0,1)');
Z_fuse = lambda * (1-mapminmax(beijing,0,1)') + (1- lambda) * ( 1-mapminmax(bgPrior',0,1)');
% Z_sal = lambda * (mapminmax(beijing,0,1)') + (1-lambda) * (mapminmax(mean_sup',0,1)');


% Z_refine = postProcessing(Z_sal, pred_lb, bdCon, fstReachMat, W, sup);
% Z_refine = postProcessing(Z_sal, result3, bdCon, fstReachMat, W, sup);
% % Z_refine = postProcessing(Z_sal, cc, bdCon, fstReachMat, W, sup);
toc;
%从这里可视化一个Z_refine的结果看看咋样后面的不要了
% coarse saliency estimation
% % zz = Z_refine;
zz = Z_fuse;

first_slience9 = zeros(y,x);
for i=1:length(pixelList)
    first_slience9(pixelList{i}) = zz(i);
end
figure;imshow(first_slience9); title('后处理的');  


% % % salMap_re = GetSaliencyMap(Z_refine, sup.pixIdx, [height,width,1,height,1,width], true);
% % % %figure;imshow(salMap_re,'border','tight');title('细粒度显著图');
% % % figure;imshow(salMap_re);title('细粒度显著图,有先验的');
figure;
[X,Y] = meshgrid(1:x,y:-1:1);         % 生成网格坐标
pcolor(X,Y,  first_slience9);
 %surf(x,y,z); view(0,90); %等效的写法
 shading interp; 
colorbar; colormap(summer);
% clim([0 1]);
xlabel('X');ylabel('Y');title('后处理，有先验的'); 

%% 细化后的结果（加入先验）
out1 = reshape(first_slience9, height*width, []);
[centers, U] = fcm( out1, 2);
[values, indexes] = max(U);
fcmClusters = reshape(indexes, [height,width]);

gt8=fcmClusters-1;
% gt8 = 1-gt8;
figure;imshow(gt8);title('后处理，有先验的');


[TN,TP,FN,FP,OE,KC]=Kappa(gt_im(:,:,1), gt8);
AC=(TP+TN)/(TP+FN+FP+TN);    %准确率
PR=TP/(TP+FP);          %精确度
RCALL=TP/(TP+FN);      %召回率
F1=2*TP/(2*TP+FP+FN);   %f1值

%计算PR曲线
DI2 = reshape(first_slience9, height*width, []);
GT2 = reshape(gt_im(:,:,1), height*width, [])/255;
[pos1, prec1, ~, AUC1] = perfcurve(GT2, DI2, 1, 'XCrit', 'reca', 'YCrit', 'prec');
AUC1


% 直接取阈值看看
t = 0.75;
first_slience10 = zeros(y,x);
first_slience10(first_slience9>t) = 1;
first_slience10(first_slience9<t) = 0;
figure;imshow(first_slience10); title('阈值分割的');

%细化后的结果（加入先验）
out1 = reshape(first_slience10, height*width, []);
[centers, U] = fcm( out1, 2);
[values, indexes] = max(U);
fcmClusters = reshape(indexes, [height,width]);

gt10=fcmClusters-1;
% gt10 = 1-gt10;
figure;imshow(gt10);title('后处理，有先验的,阈值分割');


[TN,TP,FN,FP,OE,KC]=Kappa(gt_im(:,:,1), gt10);
AC=(TP+TN)/(TP+FN+FP+TN);    %准确率
PR=TP/(TP+FP);          %精确度
RCALL=TP/(TP+FN);      %召回率
F1=2*TP/(2*TP+FP+FN);   %f1值



salMap_re = GetSaliencyMap(Z_refine, sup.pixIdx, [height,width,1,height,1,width], true);
figure;
[y,x] = size(salMap_re);                 % 取出图像大小
[X,Y] = meshgrid(1:x,y:-1:1);         % 生成网格坐标
pcolor(X,Y,  salMap_re);
 %surf(x,y,z); view(0,90); %等效的写法
 shading interp; 
colorbar; colormap(summer);
xlabel('X');ylabel('Y');title('GetSaliencyMap的');

%细化后的结果（加入先验）
out1 = reshape(salMap_re, height*width, []);
[centers, U] = fcm( out1, 2);
[values, indexes] = max(U);
fcmClusters = reshape(indexes, [height,width]);

gt9=fcmClusters-1;
% gt9 = 1-gt9;
figure;imshow(gt9);title('后处理，有先验的');


[TN,TP,FN,FP,OE,KC]=Kappa(gt_im(:,:,1), gt9);
AC=(TP+TN)/(TP+FN+FP+TN);    %准确率
PR=TP/(TP+FP);          %精确度
RCALL=TP/(TP+FN);      %召回率
F1=2*TP/(2*TP+FP+FN);   %f1值




final_cd = zeros(y,x);
for i=1:length(pixelList)
    final_cd(pixelList{i}) = pred_lb(i);
end
figure;imshow(final_cd); title('细粒度显著图');

figure;
[X,Y] = meshgrid(1:x,y:-1:1);         % 生成网格坐标
pcolor(X,Y,  final_cd);
 %surf(x,y,z); view(0,90); %等效的写法
 shading interp; 
colorbar; colormap(summer);
% clim([0 1]);
xlabel('X');ylabel('Y');title('细粒度显著图'); 


%细化后的结果
out1 = reshape(final_cd, height*width, []);
[centers, U] = fcm( out1, 2);
[values, indexes] = max(U);
fcmClusters = reshape(indexes, [height,width]);

gt1=fcmClusters-1;
% gt1 = 1-gt1;
figure;imshow(gt1);title('细化结果');


[TN,TP,FN,FP,OE,KC]=Kappa(gt_im(:,:,1), gt1);
AC=(TP+TN)/(TP+FN+FP+TN);    %准确率
PR=TP/(TP+FP);          %精确度
RCALL=TP/(TP+FN);      %召回率
F1=2*TP/(2*TP+FP+FN);   %f1值

































































